"""
This module defines all models for the finance manager application.

Attributes:
    AppProfile: Model for user profiles.
    Currency: Global model for currencies.
    Tag: Model for tags.
    PaymentSource: Model for payment sources.
    UpcomingExpense: Model for upcoming expenses.
    Transaction: Model for transactions.
    CurrentAsset: Model for current assets.
    FinancialSnapshot: Model for financial snapshots.
"""
from django.db import models
from django.utils import timezone
from django.conf import settings
from finance.management.managers import *
import uuid

# TODO: Create User Abstract model to force emails to be unique

class AppProfile(models.Model):
    """
    Model for user profiles. Automatically generated by Django when a user is created via api_tools/signals.py.

    Attributes:
        objects (AppProfileManager): Manager for the AppProfile model.
        username (OneToOneField): One-to-one relationship with the user model.
        user_id (UUIDField): Unique identifier for the user.
        spend_accounts (ManyToManyField): Many-to-many relationship with the PaymentSource model.
        base_currency (ForeignKey): Foreign key to the Currency model.
    """
    objects = AppProfileManager.as_manager()
    username = models.OneToOneField(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    user_id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    spend_accounts = models.ManyToManyField("PaymentSource", blank=True)
    base_currency = models.ForeignKey(
        "finance.Currency",
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
    )

    def __str__(self):
        return f"{self.user_id}"

class Currency(models.Model):
    """
    Global model for currencies.
    Requires population with mamangement/commands/load_currencies.py.

    Attributes:
        code (CharField): Currency code.
        name (CharField): Currency name.
        symbol (CharField): Currency symbol.
    """
    class Meta:
        verbose_name_plural = "Currencies"
        ordering = ["code"]
        constraints = [
            models.UniqueConstraint(
                fields=['code', 'name', 'symbol'],
                name='unique_currency_per_code'
            )
        ]
    code = models.CharField(max_length=3, default="USD")
    name = models.CharField(max_length=50, default="USD")
    symbol = models.CharField(max_length=5, default="$", null=True, blank=True)

    def __str__(self):
        return f"{self.code} ({self.symbol})"


class Tag(models.Model):
    """
    Model for tags. Allows users to add custom tags to transactions.
    Tags are automatically generated when a transaction is created if a tag is assigned and not found.
    
    Attributes:
        name (CharField): Name of the tag. Unique per user.
        uid (ForeignKey): Foreign key to the AppProfile model.
    """
    class Meta:
        constraints = [
            models.UniqueConstraint(fields=['name', 'uid'], name='unique_tag_per_user')
        ]
    name = models.CharField(max_length=200, )
    uid = models.ForeignKey("AppProfile", on_delete=models.CASCADE)
    objects = TagManager()
    def __str__(self):
        return self.name


class PaymentSource(models.Model):
    """
    Model for payment sources. Allows users to add payment sources to their accounts.
    Automatically generates a CurrentAsset when a PaymentSource is created.

    Attributes:
        source (CharField): Name of the payment source. unique per user.
        acc_type (CharField): Type of the payment source, selected from a list of choices.
        uid (ForeignKey): Foreign key to the AppProfile model.
    """
    objects = PaymentSourceManager.as_manager()
    class Meta:
        verbose_name_plural = "Payment Sources"
        constraints = [
            models.UniqueConstraint(fields=['source', 'uid'], name='unique_source_per_user')
        ]

    class AccType(models.TextChoices):
        SAVINGS = "SAVINGS", "Savings"
        CHECKING = "CHECKING", "Checking"
        CASH = "CASH", "Cash"
        INVESTMENT = "INVESTMENT", "Investment"
        EWALLET = "EWALLET", "Mobile Wallet"
        UNKNOWN = "UNKNOWN", "Unknown"

    source = models.CharField(max_length=50)
    acc_type = models.CharField(max_length=10, choices=AccType.choices)

    # User dependancy
    uid = models.ForeignKey("AppProfile", on_delete=models.CASCADE)

    def save(self, *args, **kwargs):
        """
        Automatically create a CurrentAsset when a PaymentSource is created.
        This ensures every PaymentSource has a corresponding asset tracking its balance.
        """
        created = self.pk is None
        super().save(*args, **kwargs)
        
        if created:
            # Get the user's base currency (should always exist)
            base_currency = self.uid.base_currency
            if not base_currency:
                # Fallback: get first currency for user if base_currency not set
                base_currency = Currency.objects.filter(uid=self.uid).first()
            
            if base_currency:
                # Create CurrentAsset with initial amount of 0
                # User can update the amount later via user_add_asset or transactions
                CurrentAsset.objects.get_or_create(
                    source=self,
                    defaults={
                        'amount': 0,
                        'currency': base_currency,
                        'uid': self.uid
                    }
                )

    def __str__(self):
        return f"{self.source} ({self.AccType})"


class UpcomingExpense(models.Model):
    """
    Model for upcoming expenses. Allows users to add planned expenses to their accounts.
    Used for calculation recurring expenses, one time major planned purchases, or short-term recurring expenses.
    Turns off recurring if the end_date is reached.

    Attributes:
        name (CharField): Name of the expense.
        amount (DecimalField): Estimated cost of the expense.
        due_date (DateField): Date the expense is due.
        start_date (DateField): Date the expense starts.
        end_date (DateField): Date the expense ends.
        paid_flag (BooleanField): Flag indicating if the expense has been paid.
        expense_id (AutoField): Unique identifier for the expense.
        is_recurring (BooleanField): Flag indicating if the expense is recurring.
        currency (ForeignKey): Foreign key to the Currency model.
        uid (ForeignKey): Foreign key to the AppProfile model.
    """
    objects = UpcomingExpenseManager.as_manager()

    class Meta:
        ordering = ["due_date"]
        constraints = [
            models.UniqueConstraint(fields=['name', 'uid'], name='unique_upcoming_expense_per_user')
        ]


    name = models.CharField(max_length=200)
    amount = models.DecimalField(max_digits=10, decimal_places=2)
    due_date = models.DateField(null=True, blank=True)
    start_date = models.DateField(null=True, blank=True)
    end_date = models.DateField(null=True, blank=True)
    paid_flag = models.BooleanField(default=False)
    expense_id = models.AutoField(primary_key=True)
    # User dependancy
    uid = models.ForeignKey("AppProfile", on_delete=models.CASCADE)
    currency = models.ForeignKey("Currency", on_delete=models.PROTECT)

    # Boolean for recurring logic
    is_recurring = models.BooleanField(default=False)

    def __str__(self):
        return f"{self.name} ({self.status}) ({self.paid_flag})"

    def save(self, *args, **kwargs):
        """
        Check if the current date has surpassed the end_date.
        If so, we flip recurring to False so it doesn't spawn next month.
        """
        if self.end_date and timezone.now().date() > self.end_date:
            self.is_recurring = False

        super().save(*args, **kwargs)


class Transaction(models.Model):
    """
    Model for transactions. Allows users to add transactions to their accounts.
    Links to signals to automically update due date and paid flag for linked bill, if linked.

    Attributes:
        date (DateField): Date of the transaction.
        description (CharField): Description of the transaction.
        amount (DecimalField): Amount of the transaction.
        source (ForeignKey): Foreign key to the PaymentSource model.
        currency (ForeignKey): Foreign key to the Currency model.
        tags (ManyToManyField): Many-to-many relationship with the Tag model.
        entry_id (AutoField): Unique identifier for the transaction.
        tx_id (CharField): Unique identifier for the transaction.
        bill (ForeignKey): Foreign key to the UpcomingExpense model.
        uid (ForeignKey): Foreign key to the AppProfile model.
        tx_type (CharField): Type of the transaction, selected from a list of choices.
    """
    objects = TransactionManager.as_manager()

    class Meta:
        ordering = ["date"]
        constraints = [
            models.UniqueConstraint(fields=['tx_id', 'uid'], name='unique_transaction_per_user')
        ]
    # Hard Coded Requirements
    date = models.DateField()
    description = models.CharField(max_length=200, null=True, blank=True)
    amount = models.DecimalField(max_digits=10, decimal_places=2, default=0)

    # Link to relationship models
    source = models.ForeignKey("PaymentSource", on_delete=models.SET_DEFAULT, default=PaymentSource.objects.get(acc_type="UNKNOWN"))
    currency = models.ForeignKey("Currency", on_delete=models.PROTECT)
    tags = models.ManyToManyField("Tag", blank=True)
    entry_id = models.AutoField(primary_key=True, db_index=True)
    tx_id = models.CharField(max_length=20, editable=False)
    bill = models.ForeignKey('UpcomingExpense', on_delete=models.SET_NULL, null=True, blank=True)

    # User dependancy
    uid = models.ForeignKey("AppProfile", on_delete=models.CASCADE)

    class TxType(models.TextChoices):
        EXPENSE = (
            "EXPENSE",
            "Expense",
        )
        INCOME = (
            "INCOME",
            "Income",
        )
        TRANSFER_IN = (
            "XFER_IN",
            "Transfer In",
        )
        TRANSFER_OUT = (
            "XFER_OUT",
            "Transfer Out",
        )

    tx_type = models.CharField(max_length=10, choices=TxType.choices)

    def save(self, *args, **kwargs):
        # Get and set a tx_id for unique transaction identifiers
        if not self.tx_id:
            day_suffix = timezone.now().year
            unique_id = str(uuid.uuid4())[:8].upper()
            self.tx_id = f"{day_suffix}-{unique_id}"

        # Set date if not set (should be done by validators)
        if not self.date:
            self.date = timezone.now().date()

        # If bill is set, change paid_flag.
        if self.bill:
            self.bill = UpcomingExpense.objects.for_user(self.uid).get_by_name(self.bill.name)
            self.bill.paid_flag = True
            self.bill.save()


        super().save(*args, **kwargs)

    def __str__(self):
        return self.tx_id


class CurrentAsset(models.Model):
    """
    Model for current assets. Allows users view assets in thier accounts.
    Automatically generated when a PaymentSource is created.
    Since this is a one-to-one relationship to PaymentSource, no methods exist to create new CurrentAssets.
    This ensures that there is only one CurrentAsset per PaymentSource, and no floating assets to sources that don't exist.

    Attributes:
        source (OneToOneField): One-to-one relationship with the PaymentSource model.
        amount (DecimalField): Amount of the asset.
        currency (ForeignKey): Foreign key to the Currency model.
        uid (ForeignKey): Foreign key to the AppProfile model.
    """
    objects = CurrentAssetManager.as_manager()

    class Meta:
        verbose_name_plural = "Current Assets"

    source = models.OneToOneField("PaymentSource", on_delete=models.PROTECT)
    amount = models.DecimalField(max_digits=15, decimal_places=2, default=0)
    currency = models.ForeignKey("Currency", on_delete=models.PROTECT)

    # User dependancy
    uid = models.ForeignKey("AppProfile", on_delete=models.CASCADE)

    def __str__(self):
        return f"{self.source.source} ({self.amount})"


class FinancialSnapshot(models.Model):
    """
    Model for financial snapshots. Allows users to view their financial data.

    Attributes:
        total_assets (DecimalField): Total assets.
        safe_to_spend (DecimalField): Total safe to spend.
        total_savings (DecimalField): Total savings.
        total_checking (DecimalField): Total checking.
        total_investment (DecimalField): Total investment.
        total_cash (DecimalField): Total cash.
        total_ewallet (DecimalField): Total mobile wallet.
        total_monthly_spending (DecimalField): Total monthly spending.
        total_remaining_expenses (DecimalField): Total remaining expenses.
        total_leaks (DecimalField): Total leaks.
        uid (OneToOneField): One-to-one relationship with the AppProfile model.
    """
    objects = FinancialSnapshotManager.as_manager()
    class Meta:
        verbose_name_plural = "Financial Snapshot"

    total_assets = models.DecimalField(max_digits=15, decimal_places=2, default=0)
    safe_to_spend = models.DecimalField(max_digits=15, decimal_places=2, default=0)
    total_savings = models.DecimalField(max_digits=15, decimal_places=2, default=0)
    total_checking = models.DecimalField(max_digits=15, decimal_places=2, default=0)
    total_investment = models.DecimalField(max_digits=15, decimal_places=2, default=0)
    total_cash = models.DecimalField(max_digits=15, decimal_places=2, default=0)
    total_ewallet = models.DecimalField(max_digits=15, decimal_places=2, default=0)
    total_monthly_spending = models.DecimalField(max_digits=15, decimal_places=2, default=0)
    total_remaining_expenses = models.DecimalField(max_digits=15, decimal_places=2, default=0)
    total_leaks = models.DecimalField(max_digits=15, decimal_places=2, default=0)  
    uid = models.OneToOneField("AppProfile", on_delete=models.CASCADE)

    def __str__(self):
        return f"{self.total_assets}, {self.safe_to_spend}, {self.total_savings}, {self.total_checking}, {self.total_investment}, {self.total_cash}, {self.total_ewallet}, {self.total_monthly_spending}, {self.total_remaining_expenses}, {self.total_leaks}"
